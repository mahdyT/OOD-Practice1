# OOD-Practice1
تمرین اول درس طراحی شی گرا. سیستم رزرو هتل
----
-- گام اول:  افزودن دو قابلیت جدید
در این مرحله لازم بود یک نسخه از پروژه تهیه کرده و در پوشه‌ی Step-01-without-OOD/ ذخیره کنیم. سپس دو قابلیت جدید زیر را به سیستم اضافه نماییم:

1.افزودن روش جدید ارسال پیام

2.افزودن روش جدید پرداخت

------------------
جدول گزارش تغییرات:


   -   تغییرات مربوط به افزودن روش جدید ارسال پیام:

1. (ایجاد کلاس) SmsSender ؛ دقیقا مانند نحوه ارسال ایمیل کار میکند و به جای ایمیل از SMS استفاده میکند

2. در کلاس ReservationService؛ افزودن کیس SMS به switch notifier در تابع makeReservation


   -   تغییرات مربوط به افزودن روش جدید پرداخت:

1. در کلاس PaymentProcessor ؛ایجاد تابع payByOnsite برای روش پرداخت حضوری با پیغام مناسب

2. در کلاس ReservationService؛ افزودن کیس Onsite به switch paymentTipe در تابع makeReservation

-------------------------
- گام دوم :  تحلیل اصول شیء گرایی
- 
| اصل طراحی | وضعیت | کلاس / کلاس‌ها | توضیح |
|-----------|--------|----------------|-------|
| SRP | رعایت شده | `LuxuryRoom` ، `PoorRoom` | می‌توان این‌گونه برداشت کرد که قابلیت‌هایی مثل `AddFreeDinner` و `AddFreeRommate` بخشی از رفتار ذاتی هر نوع اتاق هستند و مسئولیت این کلاس‌ها همچنان در محدوده تعریف و ایجاد یک نوع اتاق باقی می‌ماند. |
| SRP | نقض شده | `LuxuryRoom` ، `PoorRoom` | از دید دیگر، افزودن امکانات جانبی مانند شام رایگان یا هم‌اتاقی، مسئولیتی مستقل از مفهوم «اتاق» است و بهتر است در کلاسی مجزا مثل `RoomBenefits` پیاده‌سازی شود. |
| OCP | رعایت شده | `MessageSender` | این کلاس به‌عنوان یک انتزاع عمل می‌کند و امکان اضافه‌کردن روش‌های جدید ارسال پیام از طریق ارث‌بری را بدون نیاز به تغییر کد موجود فراهم می‌کند. |
| OCP | نقض شده | `PaymentProcessor` ، `ReservationService` | کلاس `PaymentProcessor` تمام منطق انواع پرداخت را در خود جای داده و با اضافه‌شدن هر روش جدید نیاز به تغییر دارد. این مشکل در `ReservationService` شدیدتر است چون شرط‌های متعددی برای نوع پرداخت و اعلان دارد. |
| LSP | رعایت شده | `MessageSender` و زیرکلاس‌ها | کلاس‌های `SmsSender` و `EmailSender` می‌توانند بدون ایجاد رفتار غیرمنتظره جایگزین کلاس پایه شوند. |
| LSP | نقض شده | `Room` | وجود فیلد `type` به‌صورت رشته در کلاس پایه باعث می‌شود نوع واقعی شی با نوع اعلام‌شده ناسازگار شود؛ در نتیجه شی فرزند می‌تواند رفتاری مغایر انتظار داشته باشد. |
| LSP | نقض شده | `PaymentProcessor` | این کلاس شامل متدهای متعددی است که همه پرداخت‌ها را مجبور به پیروی از یک قرارداد غیرضروری می‌کند و جایگزینی صحیح را مختل می‌سازد. |
| ISP | رعایت شده | `MessageSender` | هر کلاس ارسال پیام فقط متدهای مرتبط با خودش را پیاده‌سازی می‌کند و مجبور به وابستگی به قابلیت‌های غیرمرتبط نیست. |
| ISP | نقض شده | `PaymentProcessor` | قرار دادن چندین متد پرداخت در یک کلاس باعث می‌شود استفاده‌کننده حتی در صورت نیاز به یک روش، به سایر متدها نیز وابسته باشد. |
| DIP | رعایت شده | `SmsSender` | این کلاس به‌جای وابستگی به پیاده‌سازی مشخص، به انتزاع `MessageSender` وابسته است که انعطاف‌پذیری سیستم را افزایش می‌دهد. |
| DIP | نقض شده | `ReservationService` | دریافت مستقیم نوع پرداخت و روش اعلان در متد `makeReservation` باعث وابستگی به جزئیات متغیر می‌شود؛ درحالی‌که باید فقط با انتزاع‌ها کار کند. |
| PLK | رعایت شده | `Reservation` | دسترسی به داده‌ها به‌صورت کنترل‌شده و حداقلی فراهم شده و کلاس‌ها بیش از حد در جزئیات یکدیگر وارد نمی‌شوند. |
| PLK | نقض شده | `ReservationService` | استفاده از زنجیره‌های طولانی مثل `res.customer.city` و `res.room.price` سطح coupling را افزایش داده و قانون کمترین آگاهی را نقض می‌کند. |
| CRP | رعایت شده | `Reservation` | این کلاس به‌جای ارث‌بری، از ترکیب (`Room` و `Customer`) استفاده کرده و استفاده مجدد کد را به شکل اصولی انجام داده است. |
| CRP | نقض شده | `ReservationService` | قرار گرفتن چندین مسئولیت مختلف در یک پکیج یا ساختار باعث می‌شود کلاس‌ها برای استفاده از یک بخش، ناچار به وابستگی به بخش‌های دیگر شوند. |


